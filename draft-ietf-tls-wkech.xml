<?xml version="1.0" encoding="US-ASCII"?>

<!DOCTYPE rfc  [
  <!ENTITY nbsp    "&#160;">
<!ENTITY I-D.ietf-tls-esni SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-esni">
<!ENTITY I-D.ietf-tls-svcb-ech SYSTEM "http://xml.resource.org/public/rfc/bibxml3/reference.I-D.ietf-tls-svcb-ech">

]>

<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="yes"?>
<?rfc strict="no"?>
<?rfc rfcedstyle="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<rfc category="exp" docName="draft-ietf-tls-wkech-05" ipr="trust200902" >
  <front>
    <title abbrev="Well-Known URI for ECH">A well-known URI for publishing ECHConfigList values.</title>

    <author fullname="Stephen Farrell" initials="S." surname="Farrell">
      <organization>Trinity College Dublin</organization>

      <address>
        <postal>
          <street/>

          <city>Dublin</city>

          <region/>

          <code>2</code>

          <country>Ireland</country>
        </postal>

        <phone>+353-1-896-2354</phone>

        <email>stephen.farrell@cs.tcd.ie</email>
      </address>
    </author>

    <author initials="R." surname="Salz" fullname="Rich Salz">
        <organization>Akamai Technologies</organization>
        <address>
            <email>rsalz@akamai.com</email>
        </address>
    </author>

    <author initials="B." surname="Schwartz" fullname="Benjamin Schwartz">
      <organization>Meta Platforms, Inc.</organization>
      <address>
        <email>ietf@bemasc.net</email>
      </address>
    </author>

    <date year="2024"/>

    <area>Security Area</area>

    <workgroup>TLS</workgroup>

    <keyword>TLS</keyword>

    <keyword>ECH</keyword>

    <abstract>
        <t>
            We define a well-known URI at which an HTTP origin can
            inform an authoritative DNS server, or other interested parties,
            about its Service Bindings.
            The data can include Encrypted ClientHello (ECH)
            configurations, allowing the origin, in collaboration with DNS
            infrastructure elements, to publish and rotate its own ECH keys.
        </t>
	<t>
	  The source for this draft is in <eref target="https://github.com/sftcd/wkesni/"/>
	  Issues and PRs are welcome there too.
	</t>
      </abstract>
  </front>

  <middle>
    <section title="Introduction">

        <t>Encrypted ClientHello (ECH)
            <xref target="I-D.ietf-tls-esni"/> for TLS1.3 <xref target="RFC8446"/>
            defines a confidentiality mechanism for server names and other ClientHello content in TLS.
	    Many applications will require publication of ECHConfigList data structures in the DNS,
	    where an ECHConfigList structure contains a list of ECHConfig values. Each
            ECHConfig value contains the public component of a key pair
            that will typically be periodically (re-)generated by a web server.
            Many web infrastructures will have an API that can be used to
            dynamically update the DNS RR values containing ECHConfigList values.
            Some deployments, however, will not, and those deployments could
            benefit from a mechanism like the one defined here.
        </t>

        <t>
            Note that this is not intended for
            universal deployment, but rather for cases where the web server
            doesn't have write access to the relevant zone file (or
            equivalent). That zone file will eventually include an HTTPS or SVCB
            RR <xref target="I-D.ietf-tls-svcb-ech"/> containing the ECHConfigList.
            This mechanism is extensible to deliver other kinds of information about
            the origin, that can be of use in these circumstances, but is mainly
            intended to provide the functionality necessary for ongoing management
            of ECH keys.
        </t>

        <t>
            We use the term "zone factory" (ZF) for the entity that does have write
            access to the zone file. We assume the ZF can also
            make HTTPS requests to the web server with the ECH keys.
            We define a well-known URI <xref target="RFC8615"/> on the web server that
            allows the ZF to poll for changes to ECHConfigList values. For example, if a web server
            generates new ECHConfigList values hourly and publishes those at the well-known URI,
            the ZF can poll that URI.  When the ZF sees new values, it can check if those work, and if
            they do, then update the zone file and re-publish the zone.
        </t>

        <t>
            If ECH is being operated in split-mode then the web server (backend)
            can similarly poll the ECH client-facing server at the
            well-known URI and then create it's own value to publish
            for the ZF to read. ECH split-mode is defined in
	    <xref target="I-D.ietf-tls-esni"/> and some examples are shown
	    <xref target="examples">below</xref>.
        </t>

	<t>[[ NOTE:
	  The source for this draft is in
	  <eref target="https://github.com/sftcd/wkesni/"/>
	  Issues and PRs are welcome there too.
	]]</t>

      </section>

      <section title="Terminology">
        <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
        "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
        "OPTIONAL" in this document are to be interpreted as described in BCP
        14 <xref target="RFC2119"/> <xref target="RFC8174"/> when, and only
        when, they appear in all capitals, as shown here.</t>

    <t>We define or re-use the following terms:
    <list style="symbols">
        <t>Zone factory (ZF): an entity that has write-access to the DNS</t>
        <t>Client-Facing Server: the web server that has an ECH private value. This
            processes the outer ClientHello and attempts ECH decryption.
            The name of client-facing server will typically be the public_name value used in an
            ECHConfig.</t>
       <t>Backend: the web server that will process the inner ClientHello.
            Note that even if client-facing server and backend are on the same web server, they almost
            certainly have different DNS names.</t>
       <t>Shared-mode: this is where client-facing and backend servers are the same web server.</t>
       <t>Split-mode: this refers to the case where the client-facing server only does ECH decryption
          but the TLS session is between the client and backend, which will typically
          be on a different host to client-facing server</t>
       <t>regeninterval: the number of seconds after which the value retrieved
           after acessing a well-known URI may be changed.</t>
    </list>
    </t>

      </section>

    <section title="Example uses of the well-known URI for ECH" anchor="examples">

        <t>Some example deployments are described here.</t>

        <section title="Shared-mode deplpoyment.">


<figure title="Shared-Mode Topology with Zone Factory and DNS" anchor="shared-mode"><artwork><![CDATA[
                    +--------------------+
                    |                    |
                    |   2001:DB8::1111   | Client-
Client <----------->|                    | facing
                    |   cfs.example.com  | server
                    | backend.example.com|
                    +--------------------+
                        ^            ^
     (1) ZF reads       |            |  (2) ZF checks
         .well-known    V            V      ECHConfig
                    +--------------------+
                    |                    |
                    |   zf.example.net   | Zone Factory (ZF)
                    |                    |
                    +--------------------+
                              |
                              | (3) ZF publishes new HTTPS RR
                              V
                    +--------------------+
                    |                    |
                    |   ns.example.net   | Authoritative DNS
                    |                    |
                    +--------------------+
]]></artwork></figure>

      <t>
	  The shared-mode ECH server generates new ECHConfigList values every
	  "regeninterval" seconds via some regular, automated process (e.g.,
	  a cronjob). ECHConfigList values are "current" for an hour, and
	  remain usable for three hours from the time of generation. The
	  automated process updates the ECHConfigList values in a JSON
	  resource (see <xref target="sample-json"/>) at the well-known URI,
	  https://backend.example.com/.well-known/origin-svcb.
      </t>
      <t>
	  These steps then occur.
           <list style="numbers">
	     <t>On the ZF, another regularly executed job uses
	       an HTTP client to retrieve this JSON resource from backend.example.com.
	       The data MUST be fetched via HTTPS and the certificate validity MUST
	       be verified.</t>
	     <t>The ZF next attempts to connect to backend.example.com using these ECH values and confirms
	       that they are working.</t>
	     <t> The ZF observes that the JSON resource
	       has a regeninterval of 3600 seconds, and chooses a DNS
	       TTL of 1800.  It updates the DNS zone file for backend.example.com and re-publishes
	       the zone containing only the new ECHConfigList values.</t>
	   </list>
	  When "regeninterval" seconds have passed, the ZF attempts to
	  refresh its cached copy of the JSON resource.  If the resource has changed,
	  it repeats this process.
	 </t>

        </section>

        <section title="Split-mode, multi-CDN deplpoyment.">
	  <t>
	      The following diagram, and this entire section, is a place-holder and is
	      likely to change.</t>
<figure title="Shared-Mode Topology with Zone Factory and DNS" anchor="split-mode"><artwork><![CDATA[

                    +--------------------+
                    |                    |
                    | backend.example.com| 
                    |                    |
                    +--------------------+
                        ^            ^
                        |            |  
                        V            V 
           +--------------------+ +--------------------+
           |                    | |                    |
           |   2001:DB8::1111   | |   2001:DB8::FFFF   | Client-
Client <-->|                    | |                    | facing
           |  cfs.cdn1.example  | |  cfs.cdn2.example  | servers
           +--------------------+ +--------------------+
                        ^            ^
     (1) ZF reads       |            |  (2) ZF checks
         .well-known    V            V      ECHConfig
                    +--------------------+
                    |                    |
                    |   zf.example.net   | Zone Factory (ZF)
                    |                    |
                    +--------------------+
                              |
                              | (3) ZF publishes new HTTPS RR
                              V
                    +--------------------+
                    |                    |
                    |   ns.example.net   | Authoritative DNS
                    |                    |
                    +--------------------+
]]></artwork></figure>

            <t>
		In this topology, the overall process is similar, but certain
		actions must be repeated as described below.
           <list style="numbers">
	     <t>On the ZF, another regularly executed job uses
	       an HTTP client to retrieve this JSON resource from the
	       configured intermediaries.
	       The data MUST be fetched via HTTPS and the certificate validity MUST
	       be verified. It is TBD how the ZF knows the intermediaries.</t>
	     <t>The ZF next attempts to connect to each intermediary using the ECH values and confirms
	       that they are working. </t>
	   <t>
	       IT is TBD how the ZF sets the priorities for the backends. </t>
	   </list>
	    </t>
	 </section>
    </section>

    <section title="The origin-svcb well-known URI">

         <t>
            If the backend wants to convey information to the Zone
            Factory, it publishes the JSON content
            defined in <xref target="jsonstr"/> at:
            https://backend.example.com/.well-known/origin-svcb
        </t>

        <t>The well-known URI defined here MUST be an https URL and therefore the ZF
        can verify the correct backend is being accessed.</t>

    <t>If no new ECHConfig value verifies (as per <xref target="zfbehave"/>), then the
            zone factory MUST NOT modify the zone. </t>

    </section>


<section anchor="jsonstr" title="The JSON structure for origin service binding info">

  <t>[[ NOTE:
  JSON structure is a work in progress.]]</t>

<figure anchor="sample-json" title="Sample JSON for ECH without aliases" >
<artwork><![CDATA[
    {
        "endpoints": [{
            "regeninterval": 3600,
            "priority": 1,
            "target": "cdn.example.",
            "params": {
                "ech": "AD7+DQA65wAgAC..AA=="
            }
        }, {
            "regeninterval": 3600,
            "priority": 1,
            "params": {
                "port": 8413,
                "ech": "AD7+DQA65wAgAC..AA=="
            }
        }]
    }
  ]]></artwork>
</figure>

<figure anchor="sample-json-alias" title="Sample JSON with aliasing" >
    <artwork><![CDATA[
     {
        "endpoints": [{
            "alias": "cdn2.example.com",
            "regeninterval": 108000
        }]
      }
    ]]></artwork>
</figure>

    <t>
        The JSON file at the well-known URI MUST contain an object
	with an "endpoints" key that contains an array of objects.
        All other keys MUST be ignored.
        The length of the list implies restrictions and meaning to the content
        of the entries:
    <list style="symbols">
      <t>
        An empty endpoints array corresponds to an HTTPS record with inferred
        SvcPriority, the TargetName equal to ".", and no ECH support.  This can
        can be useful as a simple way to make use of the HTTPS RR
        type's HSTS behavior.
      </t>
      <t>
	An endpoints array with one element can be either a ServiceMode
	entry, containing at least one key from the JSON HTTP Origin Info
	registry (see <xref target="iana">IANA Considerations</xref>, below)
	or an AliasMode entry that points to another DNS name that must
        be resolved.
      </t>
      <t>
	If the endpoints array has more than one element, every item SHOULD
        be a ServiceMode entry, due to restrictions on the use of multiple AliasMode
        records (<relref target="RFC9460" section="2.4.2" displayFormat="comma" />).
      </t>
    </list>
    </t>
    <t>
	The intent of these restrictions is to reduce the chance of misconfiguration
	by the ZF and to avoid introducing semantics not defined by
        <xref target="RFC9460"/>.
    </t>

    <t>The following keys are defined for both types of entries:
    <list style="symbols">
      <t>
	  regeninterval: the number of seconds between key generation
	  actions at the origin, i.e. a replacement ECHConfigList may be
	  generated this often.
      </t>
    </list>
    </t>

    <t>The following keys are defined for ServiceMode entries:
    <list style="symbols">
      <t>
	  target: The value is a string containing a fully qualified
	  domain name, corresponding to the HTTPS record's TargetName.
	  The default value is ".".  All labels in the name MUST contain
	  only octets from the ABNF set ALPHA / DIGIT / "-" / "_".
      </t>
      <t>
	  priority: The value is a positive integer corresponding to the
	  SvcPriority.  If omitted, the ZF MAY infer
	  numerically increasing SvcPriority from the order of the
	  endpoints array.
      </t>
      <t>
	  params: A JSON Dictionary representing the SVCB SvcParams.  Each
	  key in the dictionary is a string containing a registered
	  SvcParamKey name (e.g., "ipv6hint") or a SvcParamKey in generic
	  form (e.g., "key65528").  The default value is "{}".
	<list>
	  <t>
	      For single-valued SvcParams (e.g., "ech"), the value is a JSON
	      String.  A JSON String is a sequence of Unicode codepoints,
	      while a SvcParam's presentation value is a sequence of octets,
	      so each value octet is stored as a single Unicode codepoint
	      <xref target="ISOMORPHIC-DECODE"/>.  In almost all cases, this
	      is equivalent to the ordinary string representation of the
	      presentation value.
	  </t>
	  <t>
	      For list-valued SvcParams (e.g., "alpn"), the value is a JSON Array
	      of Strings.  Each String represents an octet sequence, as in the
	      single-value case.
	  </t>
	</list>
      </t>
    </list>
  </t>

    <t>The following key is defined for AliasMode entries.

    <list style="symbols">
      <t>
	  alias: The value MUST be a DNS name that could be used as the
	  TargetName of an HTTPS resource record.  This indicates that the
	  backend is hosted on the same endpoints as this target, and is
	  equivalent to an HTTPS AliasMode record.  The ZF might implement
	  this directive by publishing an AliasMode record, publishing a
	  CNAME record, copying HTTPS records from the target zone, or
	  fetching https://cfs.example.com/.well-known/origin-svcb (if it
	  exists).
      </t>
    </list>
  </t>

  <t>These definitions, taken with the <xref target="zfbehave">ZF behaviour</xref>
      specified below, provide the following important properties:
      <list style="symbols">
	<t>
	    Origins can express any useful configuration that is representable by HTTPS records, including multiple endpoints representing different ports, providers, etc.
	</t>
	<t>
	    Origins that simply alias to a single target can indicate this
	    without copying the ECHConfig and other parameters, avoiding
	    the maintenance burden of staying synchronized with the target's
	    key rotations and configuration updates.
	</t>
      </list>
    </t>

</section>

<section anchor="zfbehave" title="Zone Factory behaviour">

    <t>
	If the ZF is unable to convert the JSON into a DNS zone (e.g., due
	to an unrecognized SvcParamKey), or if the resulting zone fails
	validation checks, the ZF MUST NOT update the DNS. Such failures
	will not be directly visible to the client-facing server, so ZF
	implementations will need to provide some form of reporting so that
	the situation can be resolved. Note that this can lead to
	inconsistent behavior for a single origin served by multiple ZFs.
    </t>

    <t>
	A ZF MAY apply additional processing according to its own policy, such as
	adjusting TTL values and correcting common misconfigurations.
    </t>

    <t>ZF SHOULD check that ECH with the presented endpoints
        succeeds with the backend before publication.
        In order to make such checks, the ZF SHOULD
        attempt to access the well-known URI defined here
        while attempting ECH.
    </t>

    <t>
        A bespoke TLS client is likely needed for this check,
        that does not require the ECHConfigList value to have
        already been published in the DNS. The TLS client also
        needs to allow checking for the success or failure of ECH.
    </t>

    <t>If more than one ECHConfig is present in an ECHConfigList,
       then the ZF SHOULD explode the ECHConfigList value
       presented into "singleton" values with one public key in each,
       and then test each of those separately.</t>

    <t>ZF SHOULD publish all the endpoints
        that are presented in the JSON file that pass
        the checks above.</t>

    <t>ZF SHOULD set a DNS TTL less than regeninterval, i.e. short enough so that any
        cached DNS resource records are likely to have expired before the JSON
        object's content is likely to have changed. The ZF
        MUST attempt to refresh the JSON object and regenerate the zone
        before this time.  This aims to ensure that ECHConfig values
        are not used longer than intended by backend.
    </t>

</section>


    <section title="Security Considerations">
        <t>
            This document defines another way to publish ECHConfigList values. If the wrong
            keys were read from here and published in the DNS, then clients
            using ECH would do the wrong thing, likely resulting in
            denial of service, or a privacy leak, or worse, when TLS clients attempt to use ECH with
            a backend web site. So: Don't do that:-)
        </t>

        <t>
            Although this configuration resource MAY be publicly
            accessible, general HTTP clients SHOULD NOT attempt to use this
            resource in lieu of HTTPS records queries through their preferred
            DNS server for the following reasons:
            <list style="symbols">
                <t>
                    The bootstrap connection would not be able to use ECH,
                    so it would reveal all the information that ECH seeks
                    to protect.
                </t>
                <t>
                    The origin could serve the user with a uniquely
                    identifying configuration, potentially resulting in an
                    unexpected tracking vector.
                </t>
            </list>
        </t>

        <t>
            The .well-known URI chosen here means that services running
            on different ports of the same backend are trusting the
            service running on the default port (443) for that backend
            to provide correct endpoint information.
        </t>

        <t>
            As described, in mutlti-CDN and simlar scenarios, a ZF might
            only test ECH success against one of the CDNs unless the ZF
            can make use of the ipv4hints and/or ipv6hint values, or the
            ZF has out of band information about the different addresses
            at which backend.example.com can be accessed.
        </t>

    </section>

    <section title="Acknowledgements">
        <t>Thanks to Niall O'Reilly, Martin Thomson and David Black for reviews.</t>
        <t>Stephen Farrell's work on this specification was supported in part by
            the Open Technology Fund.</t>
    </section>

    <section anchor="iana" title="IANA Considerations">
	<t>[[ NOTE:
	   IANA registration of a .well-known entry.
	  ]]</t>
	<t>[[ NOTE:
	  How to handle I18N for $FRONTEND and $BACKEND within such a URL.
	  ]]</t>

        <t>If approved, this specification requests the creation of an IANA
            registry named "JSON HTTP Origin Info" with a Standards Action
            registration policy, containing a field named "Name"
            whose value is a UTF-8 string.
        </t>

    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='reference.RFC.2119'?>
      <?rfc include='reference.RFC.8174'?>
      <?rfc include='reference.RFC.8446'?>
      <?rfc include='reference.RFC.8615'?>
      <?rfc include='reference.RFC.9460'?>
      &I-D.ietf-tls-esni;
      &I-D.ietf-tls-svcb-ech;

    </references>

    <references title="Informative References">
      <reference anchor="ISOMORPHIC-DECODE"
                   target="https://infra.spec.whatwg.org/#isomorphic-decode">
          <front>
            <title>WHATWG definition of Isomorphic Decode</title>
            <author fullname="WHATWG">
              <organization />
            </author>
            <date />
          </front>
        </reference>
    </references>

    <section title="Change Log ">
      <t>[[ NOTE:
	RFC editor: please remove this before publication.
      ]]</t>

      <t>The -00 WG draft replaces draft-farrell-tls-wkesni-03.</t>

      <t>
        Version 01 changed from a special-purpose design, carrying only
        ECHConfigs and port numbers, to a more general approach based on
        Service Bindings.
      </t>

      <t>
        Version 02 is just a keep-alive
      </t>

      <t>
        Version 03 reflects some local implementation experience with -02
      </t>

      <t>
        Version 04 matches a proof-of-concept bash script implementation and
        results of IETF-117 discussion.
      </t>

      <t>
          Version 05 responds to early artart and dnsop reviews, and some list
          discussion/github issues.
      </t>

    </section>
  </back>
</rfc>
